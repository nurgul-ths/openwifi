"""
script_process_lms_update_files.py

This script processes error and weight files generated by the LMS (Least Mean Squares)
algorithm implementation in the OpenWiFi project, specifically from the dac_intf_canc_ctl.c program.

It converts binary data to CSV format, calculates error values in dB, and separates
real and imaginary weight components for further analysis.

Usage:
1. Set the PATH_DATA variable to point to the directory containing LMS update files.
2. Run the script: python script_process_lms_update_files.py

The script will process all 'error_info_*' and 'weight_info_*' files in the specified directory and its subdirectories.

Data Format:
Each binary file contains multiple blocks with the following structure:
1. Block header (4 bytes): A constant value (0xDEADBEEF) to verify block integrity
2. Block size (8 bytes): Size of the following data block in bytes (unsigned 64-bit integer)
3. Data block: Contains timestamp and error/weight data (format differs for error and weight files)
   - For error files: timestamp (8 bytes, unsigned 64-bit integer) and error value (8 bytes, unsigned 64-bit integer)
   - For weight files: Multiple sets of 32 weight values (16 complex weights, each 4 bytes, unsigned 32-bit integer)
"""

import os
import struct
import csv
import numpy as np

#===============================================================================
# Configuration
#===============================================================================

# PATH_DATA = '.'  # Current directory
# PATH_DATA = '/home/andreas/gitlab_wisense/devices/openwifi_boards/experiments/online_learning/results_cnc_10mm_12bpm'
# PATH_DATA = '/home/andreas/gitlab_wisense/devices/openwifi_boards/experiments/online_learning/results_cnc_100mm_12bpm'
# PATH_DATA = '/home/andreas/gitlab_wisense/devices/openwifi_boards/experiments/online_learning/results_cnc_200mm_12bpm'

PATH_DATA = '/home/andreas/gitlab_phd/workspace_kristens/meetings/2024/phd_2024-05-08/results/online_analog_cancellation/stability'

#===============================================================================
# Constants
#===============================================================================

# REVISIT: The file header constant is fine, but this bitwidth should be read from the log file or somewhere else
# or a git commit should be given etc.
FILE_HEADER_CONSTANT = 0xDEADBEEF
DAC_FILT_BITWIDTH    = 20
DAC_FILT_N_INT       = 3
DAC_FILT_N_FRAC      = DAC_FILT_BITWIDTH - DAC_FILT_N_INT

# File format constants
BLOCK_HEADER_SIZE    = 4  # Size of the block header in bytes
BLOCK_SIZE_SIZE      = 8  # Size of the block size field in bytes
TIMESTAMP_SIZE       = 8  # Size of the timestamp in bytes
ERROR_SIZE           = 8  # Size of the error value in bytes
WEIGHT_SIZE          = 4  # Size of each weight value in bytes
NUM_COMPLEX_WEIGHTS  = 16 # Number of complex weights in each block

# File naming constants
ERROR_FILE_PREFIX    = 'error_info_'
WEIGHT_FILE_PREFIX   = 'weight_info_'
FILE_EXTENSION       = '.txt'

WEIGHT_REAL_FNAME_PREFIX = 'weight_real'
WEIGHT_IMAG_FNAME_PREFIX = 'weight_imag'

#===============================================================================
# Functions
#===============================================================================

def uint32_to_int32(value, bitwidth):
  """
  Converts an unsigned 32-bit integer to a signed 32-bit integer using two's complement.

  This function interprets the input value as a signed integer in two's complement
  representation. If the most significant bit is set (indicating a negative number
  in two's complement), it subtracts 2^bitwidth to get the correct negative value.

  Args:
    value (int): The unsigned 32-bit integer to convert.
    bitwidth (int): The bit width of the value (usually 32 for 32-bit integers).

  Returns:
    int: The converted signed 32-bit integer.

  Examples:
    >>> uint32_to_int32(0, 32)
    0
    >>> uint32_to_int32(1, 32)
    1
    >>> uint32_to_int32(2**31 - 1, 32)  # Maximum positive 32-bit integer
    2147483647
    >>> uint32_to_int32(2**31, 32)  # Minimum negative 32-bit integer
    -2147483648
    >>> uint32_to_int32(2**32 - 1, 32)  # -1 in two's complement
    -1
  """
  if value >= (1 << (bitwidth - 1)):
    return value - (1 << bitwidth)
  return value

def int32_to_float(value, n_frac):
  """
  Converts a fixed-point 32-bit integer to a floating-point number.

  This function interprets the input value as a fixed-point number with
  n_frac fractional bits. It divides the input by 2^n_frac to convert
  it to its floating-point representation.

  Args:
    value (int): The fixed-point 32-bit integer to convert.
    n_frac (int): The number of fractional bits in the fixed-point representation.

  Returns:
    float: The converted floating-point number.

  Examples:
    >>> int32_to_float(1024, 10)  # 1024 / 2^10 = 1.0
    1.0
    >>> int32_to_float(512, 10)   # 512 / 2^10 = 0.5
    0.5
    >>> int32_to_float(-1024, 10) # -1024 / 2^10 = -1.0
    -1.0
  """
  return value / (2 ** n_frac)

def process_error_files(directory):
  """
  Processes error files in the given directory and its subdirectories.

  This function reads binary error files generated by the LMS algorithm,
  converts the error values to dB, and writes them to CSV files.

  Args:
    directory (str): The root directory to start processing from.
  """
  for root, _, files in os.walk(directory):
    error_files = [f for f in files if f.startswith(ERROR_FILE_PREFIX)]

    for error_file in error_files:
      timestamp = error_file[len(ERROR_FILE_PREFIX):-len(FILE_EXTENSION)]
      output_file = os.path.join(root, f'error_data_{timestamp}.csv')

      with open(output_file, 'w', newline='') as csvfile, open(os.path.join(root, error_file), 'rb') as f:
        writer = csv.writer(csvfile)
        writer.writerow(['timestamp', 'error'])

        while True:
          # Read block header
          header = f.read(BLOCK_HEADER_SIZE)
          if not header:
            break  # End of file

          if struct.unpack('I', header)[0] != FILE_HEADER_CONSTANT:
            raise ValueError('Invalid block header')

          # Read block size
          block_size = struct.unpack('Q', f.read(BLOCK_SIZE_SIZE))[0]

          # Read timestamp and error data
          data = f.read(block_size)
          timestamp_us, error = struct.unpack('QQ', data)
          timestamp_s = timestamp_us / 1e6  # Convert to seconds
          error_db = 10 * np.log10(error)

          writer.writerow([timestamp_s, error_db])

def process_weight_files(directory):
  """
  Processes weight files in the given directory and its subdirectories.

  This function reads binary weight files generated by the LMS algorithm,
  converts the complex weights to floating-point representation, and
  writes them to separate CSV files for real and imaginary parts.

  Args:
    directory (str): The root directory to start processing from.
  """
  for root, _, files in os.walk(directory):
    weight_files = [f for f in files if f.startswith(WEIGHT_FILE_PREFIX)]

    for weight_file in weight_files:
      timestamp = weight_file[len(WEIGHT_FILE_PREFIX):-len(FILE_EXTENSION)]
      real_output_file = os.path.join(root, f'{WEIGHT_REAL_FNAME_PREFIX}_{timestamp}.csv')
      imag_output_file = os.path.join(root, f'{WEIGHT_IMAG_FNAME_PREFIX}_{timestamp}.csv')

      with open(real_output_file, 'w', newline='') as real_file, \
           open(imag_output_file, 'w', newline='') as imag_file, \
           open(os.path.join(root, weight_file), 'rb') as f:

        real_writer = csv.writer(real_file)
        imag_writer = csv.writer(imag_file)

        while True:
          # Read block header
          header = f.read(BLOCK_HEADER_SIZE)
          if not header:
            break  # End of file

          if struct.unpack('I', header)[0] != FILE_HEADER_CONSTANT:
            raise ValueError('Invalid block header')

          # Read block size
          block_size = struct.unpack('Q', f.read(BLOCK_SIZE_SIZE))[0]

          # Read weight data
          data = f.read(block_size)
          weights = struct.unpack('I' * (block_size // WEIGHT_SIZE), data)

          real_weights = [uint32_to_int32(weight, DAC_FILT_BITWIDTH) for weight in weights[::2]]
          imag_weights = [uint32_to_int32(weight, DAC_FILT_BITWIDTH) for weight in weights[1::2]]

          real_weights_float = [int32_to_float(weight, DAC_FILT_N_FRAC) for weight in real_weights]
          imag_weights_float = [int32_to_float(weight, DAC_FILT_N_FRAC) for weight in imag_weights]

          real_writer.writerow(real_weights_float)
          imag_writer.writerow(imag_weights_float)

#===============================================================================
# Main
#===============================================================================
def main():
  """
  Main function to process error and weight files generated by the LMS algorithm.

  This function orchestrates the processing of error and weight files,
  which are typically generated by the dac_intf_canc_ctl.c program in
  the OpenWiFi repository.
  """
  print("Processing error files...")
  process_error_files(PATH_DATA)

  print("Processing weight files...")
  process_weight_files(PATH_DATA)

  print("Processing complete.")

if __name__ == "__main__":
  main()
